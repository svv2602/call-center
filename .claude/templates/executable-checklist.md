# Шаблон: Исполняемый чеклист для ИИ-агента

## Использование

```
Используй шаблон из .claude/templates/executable-checklist.md
для задачи: [ОПИСАНИЕ ЗАДАЧИ]
Создай в папке: [ПУТЬ]
Источник требований: [ФАЙЛ ИЛИ ОПИСАНИЕ]
```

---

# Инструкция для ИИ-агента

## 1. Структура папки

Создай папку `{task-name}/` со следующими файлами:

```
{task-name}/
├── README.md              # Обзор задачи, цели, критерии успеха
├── PROGRESS.md            # Текущий статус (обновляется после каждой задачи)
├── phase-01-{название}.md # Первая фаза
├── phase-02-{название}.md # Вторая фаза
└── phase-NN-{название}.md # N-ная фаза
```

---

## 2. Формат README.md

```markdown
# {Название задачи}

## Цель
[Краткое описание конечной цели]

## Критерии успеха
- [ ] Критерий 1
- [ ] Критерий 2
- [ ] Критерий 3

## Фазы работы
1. [Название фазы 1] — краткое описание
2. [Название фазы 2] — краткое описание
3. ...

## Источник требований
[Ссылка на документ или описание]

## Правила переиспользования кода

### ОБЯЗАТЕЛЬНО перед реализацией:
1. **Поиск существующего функционала** — перед написанием нового кода ВСЕГДА ищи похожий существующий код
2. **Анализ паттернов** — изучи как реализованы похожие фичи в проекте
3. **Переиспользование модулей** — используй существующие модули, базовые классы, утилиты

### Где искать:
```
src/
├── core/                # Ядро обработки звонков
│   ├── audio_socket.py  # AudioSocket сервер — паттерн TCP-обработки
│   ├── call_session.py  # Управление сессией — паттерн state machine
│   └── pipeline.py      # STT → LLM → TTS — паттерн оркестрации
├── stt/                 # Speech-to-Text — паттерн абстракции внешних сервисов
│   ├── base.py          # Абстрактный интерфейс (Protocol)
│   └── google_stt.py    # Реализация Google Cloud STT
├── tts/                 # Text-to-Speech — аналогичный паттерн
│   ├── base.py
│   └── google_tts.py
├── agent/               # LLM агент
│   ├── agent.py         # Логика агента — паттерн tool calling
│   ├── prompts.py       # Системные промпты
│   └── tools.py         # Tool definitions (канонический список: doc/development/00-overview.md)
├── api/                 # REST API (FastAPI)
│   └── routes.py        # Health checks, мониторинг
├── store_client/        # Клиент Store API — паттерн circuit breaker + retry
│   └── client.py
└── config.py            # Конфигурация через env variables
```

### Чеклист перед написанием кода:
- [ ] Искал похожий функционал в codebase?
- [ ] Изучил паттерны из похожих файлов?
- [ ] Переиспользую существующие модули/утилиты?
- [ ] Соблюдаю conventions проекта?

## Правила кода

### Архитектурные паттерны проекта:

| Паттерн | Где применяется | Пример |
|---------|----------------|--------|
| Protocol (абстракция) | STT, TTS, LLM | `class STTEngine(Protocol)` |
| Circuit Breaker | Store API | `aiobreaker.CircuitBreaker(fail_max=5, timeout=30)` |
| Structured JSON logs | Все компоненты | `{"call_id": "...", "component": "...", "event": "..."}` |
| PII Sanitizer | Логирование | `PIISanitizer.sanitize(text)` — маскирует телефоны, имена |
| Graceful degradation | Внешние сервисы | Сбой → переключение на оператора, не обрыв звонка |
| TTL на сессиях | Redis | `setex("call_session:{uuid}", ttl=1800, ...)` |
| Idempotency-Key | Store API mutations | POST /orders, POST /orders/{id}/confirm |

### Async паттерны:
- Все I/O операции — `async/await`
- Каждый звонок — отдельная `asyncio.Task`
- Streaming: STT (gRPC), TTS (по предложениям), LLM (token streaming)
- Буферизация аудио в pipeline

### Чеклист:
- [ ] Все I/O через async/await?
- [ ] call_id пробрасывается через все компоненты?
- [ ] PII маскируется в логах?
- [ ] Ошибки внешних сервисов обработаны (fallback → оператор)?
- [ ] mypy --strict проходит?
- [ ] ruff check проходит?

## Правила интеграции с внешними сервисами

### Текущее состояние:
- Google STT: streaming gRPC, мультиязычный (uk-UA + ru-RU)
- Google TTS: REST, голос uk-UA-Neural2-A
- Claude API: REST, tool calling
- Store API: REST/JSON, Bearer token auth
- Asterisk: AudioSocket TCP, ARI для управления

### При добавлении нового сервиса:
1. Создай абстрактный интерфейс (Protocol) в `base.py`
2. Реализуй конкретный класс
3. Добавь mock-реализацию для тестов
4. Добавь конфигурацию через env variables
5. Добавь метрики (latency, errors) в Prometheus

### При добавлении нового tool:
1. Добавь в канонический список: `doc/development/00-overview.md`
2. Определи schema в `agent/tools.py`
3. Реализуй в `store_client/client.py`
4. Добавь тесты (unit + adversarial)

### Чеклист:
- [ ] Абстракция через Protocol?
- [ ] Mock-реализация для тестов?
- [ ] Env variables для конфигурации?
- [ ] Circuit breaker / retry для внешних вызовов?
- [ ] Метрики Prometheus добавлены?

## Правила тестирования

### Для каждого модуля:
- [ ] Unit-тесты (pytest, mock внешних API)
- [ ] Adversarial-тесты для agent (prompt injection, невалидные параметры)
- [ ] Проверка PII sanitizer для новых полей

### Запуск:
```bash
pytest tests/unit/                        # unit
pytest tests/integration/                 # integration (нужен Docker)
pytest tests/unit/test_audio_socket.py -v # один файл
pytest tests/ --cov=src --cov-report=html # с покрытием
```

## Начало работы
Для начала или продолжения работы прочитай PROGRESS.md
```

---

## 3. Формат PROGRESS.md

```markdown
# Прогресс выполнения

## Текущий статус
- **Последнее обновление:** YYYY-MM-DD HH:MM
- **Текущая фаза:** N из M
- **Статус фазы:** не начата | в процессе | завершена
- **Общий прогресс:** X/Y задач (Z%)

## Как продолжить работу
1. Открой файл текущей фазы: `phase-{N}-{название}.md`
2. Найди первую незавершённую задачу (без [x])
3. Выполни задачу
4. Отметь [x] в чекбоксе
5. Обнови этот файл (PROGRESS.md)

## История выполнения
| Дата | Событие |
|------|---------|
| YYYY-MM-DD | Проект создан |
```

---

## 4. Формат файла фазы (phase-NN-{название}.md)

```markdown
# Фаза N: {Название}

## Статус
- [ ] Не начата
- [ ] В процессе
- [ ] Завершена

**Начата:** -
**Завершена:** -

## Цель фазы
[Что должно быть достигнуто по завершении этой фазы]

## Задачи

### N.0 ОБЯЗАТЕЛЬНО: Анализ и планирование

#### A. Анализ существующего кода
- [ ] Найти похожий функционал в codebase
- [ ] Изучить паттерны из похожих файлов
- [ ] Определить что можно переиспользовать

**Команды для поиска:**
```bash
# Структура модулей
ls src/
# Поиск интерфейсов/протоколов
grep -rn "class.*Protocol" src/
# Поиск существующих tools
grep -rn "\"name\":" src/agent/tools.py
# Поиск паттернов обработки ошибок
grep -rn "CircuitBreaker\|retry\|fallback" src/
# Поиск тестов
ls tests/unit/ tests/integration/
```

#### B. Анализ зависимостей
- [ ] Нужны ли новые абстракции (Protocol)?
- [ ] Нужны ли новые env variables?
- [ ] Нужны ли новые tools для LLM-агента?
- [ ] Нужны ли миграции БД (Alembic)?

**Новые абстракции:** -
**Новые env variables:** -
**Новые tools:** -
**Миграции БД:** -

#### C. Проверка архитектуры
- [ ] Использую async/await для всех I/O?
- [ ] call_id пробрасывается сквозь все вызовы?
- [ ] Graceful degradation при сбое?
- [ ] Метрики Prometheus добавлены?

**Референс-модуль:** -

**Цель:** Понять существующие паттерны проекта ПЕРЕД написанием кода.

**Заметки для переиспользования:** -

---

### N.1 {Название задачи}
- [ ] Подзадача 1.1
- [ ] Подзадача 1.2
- [ ] Подзадача 1.3

**Файлы:** `путь/к/файлу.py`
**Заметки:** -

---

### N.2 {Название задачи}
- [ ] Подзадача 2.1
- [ ] Подзадача 2.2

**Файлы:** -
**Заметки:** -

---

## При завершении фазы

Выполни следующие действия:

1. Убедись, что все задачи отмечены [x]
2. Измени статус фазы:
   - [x] Завершена
3. Заполни дату "Завершена: YYYY-MM-DD"
4. Выполни коммит:
   ```bash
   git add .
   git commit -m "checklist({task-name}): phase-N {название} completed"
   ```
5. Обнови PROGRESS.md:
   - Текущая фаза: N+1
   - Добавь запись в историю
6. Открой следующую фазу и продолжи работу
```

---

## 5. Протокол работы агента

### При начале сессии
1. Прочитай `PROGRESS.md` чтобы определить текущее состояние
2. Открой файл текущей фазы
3. Найди первую незавершённую задачу

### При начале новой фазы (КРИТИЧЕСКИ ВАЖНО)
1. **ПЕРВАЯ задача фазы — ВСЕГДА "N.0 Анализ и планирование"**
2. **A. Анализ кода:** Поиск существующего функционала, изучение паттернов
3. **B. Анализ зависимостей:** Определи нужные абстракции, env vars, tools, миграции
4. **C. Проверка архитектуры:** Выбери референс-модуль для стиля кода
5. Заполни все заметки в задаче N.0
6. Только после этого переходи к реализации

### При выполнении задачи
1. **Перед написанием кода** — проверь заметки из задачи N.0
2. Выполни задачу, переиспользуя найденные паттерны
3. Сразу отметь чекбокс как [x]
4. Добавь заметки если нужно
5. При необходимости укажи изменённые файлы

### При завершении фазы
1. Проверь все задачи [x]
2. Обнови статус фазы
3. Сделай коммит с сообщением формата:
   `checklist({task-name}): phase-N {название} completed`
4. Обнови PROGRESS.md
5. Переходи к следующей фазе

### При сбое/прерывании
1. Сохрани текущий прогресс (отметь выполненные задачи)
2. Обнови PROGRESS.md с текущим статусом
3. При возобновлении — начни с чтения PROGRESS.md

---

## 6. Правила именования

- **Папка задачи:** `kebab-case` (например: `audiosocket-server`, `store-api-client`)
- **Файлы фаз:** `phase-NN-kebab-case.md` (например: `phase-01-preparation.md`)
- **Коммиты:** `checklist({task-name}): phase-N {description}`

---

## 7. Статусы задач

| Маркер | Значение |
|--------|----------|
| `[ ]` | Не выполнена |
| `[x]` | Выполнена |
| `[~]` | В процессе (опционально) |
| `[!]` | Заблокирована (опционально) |

---

## Пример использования

**Промпт пользователя:**
```
Используй шаблон из .claude/templates/executable-checklist.md
для задачи: Реализация AudioSocket сервера
Создай в папке: /checklists/audiosocket-server
Источник требований: doc/development/phase-1-mvp.md (п. 1.2)
```

**Результат:** Агент создаёт структуру папок и файлов, затем последовательно выполняет все фазы с автоматическим отслеживанием прогресса.
